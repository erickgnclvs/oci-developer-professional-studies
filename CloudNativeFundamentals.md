# Module 1: Cloud Native Fundamentals

- DevOps
- Kubernetes
- Docker
- Serverless Functions
- API's
- Stream Processing with Kafka

### Why Cloud Native?
- **Enhanced customer experience**
  - Facilitate frequent changes
  - Robustly develop and deliver solutions
  - Written, tested and deployed on the cloud
  - Operational efficiency
 
- **Cost effectiveness**
  - Convert capital expenditure into operational expenditure
  - Management and monitoring tools being used

- **Ease of management**
  - Provides a useful app development process
  - Empower the corporate teams

- **Digital transformation with better security measures and analytics**

### Cloud-Native, Cloud-Enabled and Cloud-Based Applications
- Cloud-Native systems are constructed in the cloud from scratch to harness the power of popular public cloud environments
- Cloud-Enabled applications is an application that has been moved to the cloud but was originally developed for use in a conventional data center
- Cloud-Based is the middle ground between Cloud-Native and Cloud-Enabled

### Cloud-Native versus Cloud-Based Applications

| Characteristic   |      Cloud-Native Applications      |  Cloud-Based Applications |
|----------|-------------|-------|
| **Origin** |  Built and deployed in the cloud, truly accessing the power of cloud infrastructure | Made in house using legacy infrastructure and tweaked to be made remotely available in the cloud |
| **Design** |    Designed to be hosted as multi-tenant instances   |   Made on in-house servers; Don't have multi-tenant instances |
| **Ease of Use** | Flexible and built to scale and areas of an app can be upgraded without disruption |    Require manual upgrades, causing distruption and shutdown to the application |
| **Pricing** | Cheaper |   More expensive |
| **Maintenance** | interruptions are limited because of the microservice architechture |   Interruptions can occur because of hardware migration or specialized software configurations |
